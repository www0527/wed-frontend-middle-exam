name: Sync Issues

on:
  issues:
    types: [opened, edited, assigned, unassigned, closed, reopened]

jobs:
  sync_issues:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'

      - name: Run script
        uses: actions/github-script@v7
        with:
          script: |
            const targetRepos = [
              {
                owner: 'owner1',
                repo: 'repo1',
                syncActions: ['opened', 'edited', 'assigned', 'unassigned', 'closed', 'reopened'],
                excludedLabels: ['exclude'],
                prependTitle: '[Sync]'
              },
              {
                owner: 'owner2',
                repo: 'repo2',
                syncActions: ['opened', 'edited', 'assigned', 'unassigned', 'closed', 'reopened'],
                excludedLabels: ['exclude'],
                prependTitle: '[Sync]'
              }
            ];

            const sourceIssue = context.payload.issue;

            const bodyTemplate = (url, body, repoName, assignee) => `
              Developer: ${assignee ? `@${assignee}` : ''}

              ---

              ${body || ''}

              ---

              *Synced from ${context.repo.owner}/${context.repo.repo} to ${repoName}*`;

            try {
              for (const { owner, repo, syncActions, excludedLabels = [], prependTitle } of targetRepos) {
                const repoName = `${owner}/${repo}`;

                // 檢查動作是否允許
                if (!syncActions.includes(context.payload.action)) {
                  console.log(`Action "${context.payload.action}" not allowed for ${repoName}`);
                  continue;
                }

                // 檢查是否有排除的標籤
                const hasExcludedLabel = excludedLabels.length > 0 &&
                  sourceIssue.labels.some(label => excludedLabels.includes(label.name));
                if (hasExcludedLabel) {
                  console.log(`Skipping sync for issue with excluded label in ${repoName}`);
                  continue;
                }

                // 獲取當前指派的開發者資訊
                const assignee = sourceIssue.assignees.length > 0
                  ? sourceIssue.assignees.map(user => user.login).join(', ')
                  : null;

                // 構建標題（加上前綴）
                const title = prependTitle
                  ? `${prependTitle} ${sourceIssue.title}` // 在標題前加前綴
                  : sourceIssue.title;

                // 動作為新增 Issue 時
                if (context.payload.action === 'opened') {
                  await github.rest.issues.create({
                    owner,
                    repo,
                    title: title,
                    body: bodyTemplate(sourceIssue.html_url, sourceIssue.body, repoName, assignee),
                    labels: sourceIssue.labels.map(label => label.name)
                  });
                  console.log(`Successfully created sync issue in ${repoName}`);
                }

                // 動作為編輯或指派變更時
                if (['edited', 'assigned', 'unassigned', 'closed', 'reopened'].includes(context.payload.action)) {
                  const searchQuery = `repo:${owner}/${repo} "Original Issue: ${sourceIssue.html_url}"`;
                  const searchResult = await github.rest.search.issuesAndPullRequests({
                    q: searchQuery
                  });

                  if (searchResult.data.items.length > 0) {
                    const targetIssue = searchResult.data.items[0];
                    await github.rest.issues.update({
                      owner,
                      repo,
                      issue_number: targetIssue.number,
                      title: title, // 更新後標題仍保持前綴
                      body: bodyTemplate(sourceIssue.html_url, sourceIssue.body, repoName, assignee)
                    });
                    console.log(`Successfully updated sync issue in ${repoName}`);
                  }
                }
              }
            } catch (error) {
              console.error('Error:', error);
              core.setFailed(error.message);
            }
